<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coding Interview Patterns</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; background: #f4f4f4; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); overflow: hidden; }
        .header { background: #667eea; color: white; padding: 20px; text-align: center; }
        .content { padding: 20px; }
        .pattern { margin-bottom: 30px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; }
        .pattern-header { background: #667eea; color: white; padding: 15px; cursor: pointer; }
        .pattern-content { padding: 15px; display: none; }
        .pattern-content.active { display: block; }
        .section { margin-bottom: 15px; padding: 10px; border-radius: 5px; }
        .description { background: #f8f9fa; border-left: 3px solid #667eea; }
        .recognition { background: #e8f5e8; border-left: 3px solid #28a745; }
        .approach { background: #fff3cd; border-left: 3px solid #ffc107; }
        .examples { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; margin-top: 15px; }
        .example { border: 1px solid #ddd; border-radius: 5px; padding: 10px; background: #fff; }
        .example-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .badge { padding: 3px 8px; border-radius: 12px; font-size: 12px; font-weight: bold; }
        .easy { background: #d4edda; color: #155724; }
        .medium { background: #fff3cd; color: #856404; }
        .hard { background: #f8d7da; color: #721c24; }
        .code { background: #f1f1f1; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 13px; margin-top: 8px; overflow-x: auto; }
        h1 { font-size: 24px; margin-bottom: 10px; }
        h2 { font-size: 18px; }
        h3 { font-size: 16px; font-weight: bold; margin-bottom: 8px; }
        ul { margin-left: 20px; }
        li { margin-bottom: 5px; }
        @media (max-width: 768px) { .container { margin: 10px; } .content { padding: 15px; } .examples { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Coding Interview Patterns Guide</h1>
            <p>Essential patterns from "Cracking the Coding Interview"</p>
        </div>
        
        <div class="content">
            <!-- Two Pointers -->
            <div class="pattern">
                <div class="pattern-header" onclick="toggle(this)">
                    <h2>Two Pointers</h2>
                </div>
                <div class="pattern-content">
                    <div class="section description">
                        <h3>üìã Description</h3>
                        <p>Uses two pointers to traverse arrays/lists. Pointers move toward each other, same direction, or different speeds.</p>
                    </div>
                    <div class="section recognition">
                        <h3>üîç Recognition</h3>
                        <ul>
                            <li>Sorted array problems</li>
                            <li>Finding pairs/triplets</li>
                            <li>Palindrome problems</li>
                            <li>Removing duplicates</li>
                        </ul>
                    </div>
                    <div class="section approach">
                        <h3>üéØ Approach</h3>
                        <ul>
                            <li>Initialize two pointers</li>
                            <li>Move based on conditions</li>
                            <li>Continue until meet/cross</li>
                            <li>Time: O(n), Space: O(1)</li>
                        </ul>
                    </div>
                    <div class="examples">
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Two Sum II (LC 167)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Find two numbers that sum to target</p>
                            <div class="code">left, right = 0, len(nums)-1
while left < right:
    if nums[left] + nums[right] == target:
        return [left+1, right+1]
    elif nums[left] + nums[right] < target:
        left += 1
    else:
        right -= 1</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Valid Palindrome (LC 125)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Check if string is palindrome</p>
                            <div class="code">left, right = 0, len(s)-1
while left < right:
    if not s[left].isalnum():
        left += 1
    elif not s[right].isalnum():
        right -= 1
    elif s[left].lower() != s[right].lower():
        return False
    else:
        left, right = left+1, right-1</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>3Sum (LC 15)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Find triplets that sum to zero</p>
                            <div class="code">nums.sort()
result = []
for i in range(len(nums)-2):
    if i > 0 and nums[i] == nums[i-1]:
        continue
    left, right = i+1, len(nums)-1
    while left < right:
        total = nums[i] + nums[left] + nums[right]
        if total == 0:
            result.append([nums[i], nums[left], nums[right]])
            # skip duplicates</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Container With Most Water (LC 11)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Find maximum water container area</p>
                            <div class="code">left, right = 0, len(height)-1
max_area = 0
while left < right:
    area = (right - left) * min(height[left], height[right])
    max_area = max(max_area, area)
    if height[left] < height[right]:
        left += 1
    else:
        right -= 1</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sliding Window -->
            <div class="pattern">
                <div class="pattern-header" onclick="toggle(this)">
                    <h2>Sliding Window</h2>
                </div>
                <div class="pattern-content">
                    <div class="section description">
                        <h3>üìã Description</h3>
                        <p>Window slides over data to find optimal solutions. Can be fixed or variable size.</p>
                    </div>
                    <div class="section recognition">
                        <h3>üîç Recognition</h3>
                        <ul>
                            <li>Subarray/substring problems</li>
                            <li>Min/max window size</li>
                            <li>Contiguous sequences</li>
                            <li>Fixed window size k</li>
                        </ul>
                    </div>
                    <div class="section approach">
                        <h3>üéØ Approach</h3>
                        <ul>
                            <li>Define window boundaries</li>
                            <li>Expand right pointer</li>
                            <li>Contract left when needed</li>
                            <li>Track optimal result</li>
                        </ul>
                    </div>
                    <div class="examples">
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Best Time to Buy/Sell Stock (LC 121)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Maximum profit from one transaction</p>
                            <div class="code">min_price = float('inf')
max_profit = 0
for price in prices:
    min_price = min(min_price, price)
    profit = price - min_price
    max_profit = max(max_profit, profit)
return max_profit</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Maximum Average Subarray (LC 643)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Find max average of subarray length k</p>
                            <div class="code">window_sum = sum(nums[:k])
max_sum = window_sum
for i in range(k, len(nums)):
    window_sum = window_sum - nums[i-k] + nums[i]
    max_sum = max(max_sum, window_sum)
return max_sum / k</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Longest Substring Without Repeating (LC 3)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Longest substring without repeating chars</p>
                            <div class="code">left = 0
char_set = set()
max_len = 0
for right in range(len(s)):
    while s[right] in char_set:
        char_set.remove(s[left])
        left += 1
    char_set.add(s[right])
    max_len = max(max_len, right - left + 1)</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Minimum Window Substring (LC 76)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Smallest window containing all chars of t</p>
                            <div class="code">from collections import Counter
target_count = Counter(t)
left = 0
min_len = float('inf')
min_start = 0
formed = 0
window_counts = {}

for right in range(len(s)):
    # Add right char to window
    # Contract window when valid</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Fast & Slow Pointers -->
            <div class="pattern">
                <div class="pattern-header" onclick="toggle(this)">
                    <h2>Fast & Slow Pointers</h2>
                </div>
                <div class="pattern-content">
                    <div class="section description">
                        <h3>üìã Description</h3>
                        <p>Two pointers at different speeds. Used for cycle detection and finding middle elements.</p>
                    </div>
                    <div class="section recognition">
                        <h3>üîç Recognition</h3>
                        <ul>
                            <li>Cycle detection</li>
                            <li>Finding middle element</li>
                            <li>Finding nth from end</li>
                            <li>Palindrome linked lists</li>
                        </ul>
                    </div>
                    <div class="section approach">
                        <h3>üéØ Approach</h3>
                        <ul>
                            <li>Slow pointer: 1 step</li>
                            <li>Fast pointer: 2 steps</li>
                            <li>If they meet: cycle exists</li>
                            <li>When fast reaches end: slow at middle</li>
                        </ul>
                    </div>
                    <div class="examples">
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Linked List Cycle (LC 141)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Detect if linked list has cycle</p>
                            <div class="code">slow = fast = head
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
    if slow == fast:
        return True
return False</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Middle of Linked List (LC 876)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Find middle node of linked list</p>
                            <div class="code">slow = fast = head
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
return slow</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Linked List Cycle II (LC 142)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Find where cycle begins</p>
                            <div class="code">slow = fast = head
# Detect cycle
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
    if slow == fast:
        break
else:
    return None
# Find start of cycle
slow = head
while slow != fast:
    slow = slow.next
    fast = fast.next</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Happy Number (LC 202)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Determine if number is happy</p>
                            <div class="code">def get_next(n):
    total = 0
    while n > 0:
        digit = n % 10
        total += digit * digit
        n //= 10
    return total

slow = fast = n
while True:
    slow = get_next(slow)
    fast = get_next(get_next(fast))
    if slow == fast:
        break
return slow == 1</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Merge Intervals -->
            <div class="pattern">
                <div class="pattern-header" onclick="toggle(this)">
                    <h2>Merge Intervals</h2>
                </div>
                <div class="pattern-content">
                    <div class="section description">
                        <h3>üìã Description</h3>
                        <p>Deal with overlapping intervals. Sort intervals and merge overlapping ones.</p>
                    </div>
                    <div class="section recognition">
                        <h3>üîç Recognition</h3>
                        <ul>
                            <li>Time intervals</li>
                            <li>Scheduling conflicts</li>
                            <li>Overlapping ranges</li>
                            <li>Free time slots</li>
                        </ul>
                    </div>
                    <div class="section approach">
                        <h3>üéØ Approach</h3>
                        <ul>
                            <li>Sort by start time</li>
                            <li>Iterate through intervals</li>
                            <li>Merge if overlapping</li>
                            <li>Handle edge cases</li>
                        </ul>
                    </div>
                    <div class="examples">
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Meeting Rooms (LC 252)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Can attend all meetings?</p>
                            <div class="code">intervals.sort(key=lambda x: x[0])
for i in range(1, len(intervals)):
    if intervals[i][0] < intervals[i-1][1]:
        return False
return True</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Summary Ranges (LC 228)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Return smallest sorted list of ranges</p>
                            <div class="code">result = []
start = nums[0]
for i in range(1, len(nums)):
    if nums[i] != nums[i-1] + 1:
        if start == nums[i-1]:
            result.append(str(start))
        else:
            result.append(f"{start}->{nums[i-1]}")
        start = nums[i]</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Merge Intervals (LC 56)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Merge overlapping intervals</p>
                            <div class="code">intervals.sort(key=lambda x: x[0])
merged = [intervals[0]]
for current in intervals[1:]:
    if current[0] <= merged[-1][1]:
        merged[-1][1] = max(merged[-1][1], current[1])
    else:
        merged.append(current)
return merged</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Insert Interval (LC 57)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Insert and merge interval</p>
                            <div class="code">result = []
for i, interval in enumerate(intervals):
    if interval[1] < newInterval[0]:
        result.append(interval)
    elif interval[0] > newInterval[1]:
        result.append(newInterval)
        return result + intervals[i:]
    else:
        newInterval = [min(interval[0], newInterval[0]),
                      max(interval[1], newInterval[1])]</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Cyclic Sort -->
            <div class="pattern">
                <div class="pattern-header" onclick="toggle(this)">
                    <h2>Cyclic Sort</h2>
                </div>
                <div class="pattern-content">
                    <div class="section description">
                        <h3>üìã Description</h3>
                        <p>Place elements at correct positions based on their values. For arrays with numbers in range [1,n].</p>
                    </div>
                    <div class="section recognition">
                        <h3>üîç Recognition</h3>
                        <ul>
                            <li>Array with numbers [1,n] or [0,n-1]</li>
                            <li>Finding missing numbers</li>
                            <li>Finding duplicates</li>
                            <li>In-place sorting needed</li>
                        </ul>
                    </div>
                    <div class="section approach">
                        <h3>üéØ Approach</h3>
                        <ul>
                            <li>Iterate through array</li>
                            <li>Place each at correct index</li>
                            <li>Use swapping for O(1) space</li>
                            <li>Continue until all correct</li>
                        </ul>
                    </div>
                    <div class="examples">
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Missing Number (LC 268)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Find missing number in array</p>
                            <div class="code">i = 0
while i < len(nums):
    if nums[i] < len(nums) and nums[i] != nums[nums[i]]:
        nums[nums[i]], nums[i] = nums[i], nums[nums[i]]
    else:
        i += 1
# Find missing
for i in range(len(nums)):
    if nums[i] != i:
        return i</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Find All Numbers Disappeared (LC 448)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Find disappeared numbers</p>
                            <div class="code">i = 0
while i < len(nums):
    correct_pos = nums[i] - 1
    if nums[i] != nums[correct_pos]:
        nums[i], nums[correct_pos] = nums[correct_pos], nums[i]
    else:
        i += 1
# Find missing
result = []
for i in range(len(nums)):
    if nums[i] != i + 1:
        result.append(i + 1)</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Find Duplicate Number (LC 287)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Find duplicate in array</p>
                            <div class="code"># Using Floyd's algorithm
slow = fast = nums[0]
# Find intersection
while True:
    slow = nums[slow]
    fast = nums[nums[fast]]
    if slow == fast:
        break
# Find entrance to cycle
slow = nums[0]
while slow != fast:
    slow = nums[slow]
    fast = nums[fast]
return slow</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Find All Duplicates (LC 442)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Find all duplicates in array</p>
                            <div class="code">result = []
for i in range(len(nums)):
    index = abs(nums[i]) - 1
    if nums[index] < 0:
        result.append(abs(nums[i]))
    else:
        nums[index] = -nums[index]
return result</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- In-place Reversal -->
            <div class="pattern">
                <div class="pattern-header" onclick="toggle(this)">
                    <h2>In-place Reversal of LinkedList</h2>
                </div>
                <div class="pattern-content">
                    <div class="section description">
                        <h3>üìã Description</h3>
                        <p>Reverse linked list parts without extra space. Change next pointers of nodes.</p>
                    </div>
                    <div class="section recognition">
                        <h3>üîç Recognition</h3>
                        <ul>
                            <li>Reversing linked list</li>
                            <li>Reversing specific positions</li>
                            <li>Rotating linked list</li>
                            <li>O(1) space requirement</li>
                        </ul>
                    </div>
                    <div class="section approach">
                        <h3>üéØ Approach</h3>
                        <ul>
                            <li>Use prev, current, next pointers</li>
                            <li>Reverse links by updating next</li>
                            <li>Handle edge cases</li>
                            <li>Track start/end for partial</li>
                        </ul>
                    </div>
                    <div class="examples">
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Reverse Linked List (LC 206)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Reverse entire linked list</p>
                            <div class="code">prev = None
current = head
while current:
    next_temp = current.next
    current.next = prev
    prev = current
    current = next_temp
return prev</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Palindrome Linked List (LC 234)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Check if linked list is palindrome</p>
                            <div class="code"># Find middle
slow = fast = head
while fast.next and fast.next.next:
    slow = slow.next
    fast = fast.next.next

# Reverse second half
prev = None
current = slow.next
while current:
    next_temp = current.next
    current.next = prev
    prev = current
    current = next_temp</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Reverse Linked List II (LC 92)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Reverse from position m to n</p>
                            <div class="code">dummy = ListNode(0)
dummy.next = head
prev = dummy

# Move to position m-1
for _ in range(left - 1):
    prev = prev.next

# Reverse portion
current = prev.next
for _ in range(right - left):
    next_node = current.next
    current.next = next_node.next
    next_node.next = prev.next
    prev.next = next_node</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Rotate List (LC 61)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Rotate list to right by k places</p>
                            <div class="code"># Find length and make circular
length = 1
tail = head
while tail.next:
    tail = tail.next
    length += 1
tail.next = head

# Find new tail
k = k % length
for _ in range(length - k):
    tail = tail.next

new_head = tail.next
tail.next = None
return new_head</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tree DFS -->
            <div class="pattern">
                <div class="pattern-header" onclick="toggle(this)">
                    <h2>Tree Depth First Search (DFS)</h2>
                </div>
                <div class="pattern-content">
                    <div class="section description">
                        <h3>üìã Description</h3>
                        <p>Traverse trees depth-first using recursion or stack. Visit node before/after children.</p>
                    </div>
                    <div class="section recognition">
                        <h3>üîç Recognition</h3>
                        <ul>
                            <li>Tree traversal problems</li>
                            <li>Finding paths in trees</li>
                            <li>Tree validation</li>
                            <li>Visiting all nodes</li>
                        </ul>
                    </div>
                    <div class="section approach">
                        <h3>üéØ Approach</h3>
                        <ul>
                            <li>Use recursion or stack</li>
                            <li>Process node, recurse children</li>
                            <li>Handle base cases (null)</li>
                            <li>Preorder/Inorder/Postorder</li>
                        </ul>
                    </div>
                    <div class="examples">
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Maximum Depth of Binary Tree (LC 104)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Find maximum depth</p>
                            <div class="code">def maxDepth(root):
    if not root:
        return 0
    return 1 + max(maxDepth(root.left), maxDepth(root.right))</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Same Tree (LC 100)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Check if two trees are same</p>
                            <div class="code">def isSameTree(p, q):
    if not p and not q:
        return True
    if not p or not q:
        return False
    return (p.val == q.val and 
            isSameTree(p.left, q.left) and 
            isSameTree(p.right, q.right))</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Path Sum (LC 112)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Check if path exists with target sum</p>
                            <div class="code">def hasPathSum(root, targetSum):
    if not root:
        return False
    if not root.left and not root.right:
        return root.val == targetSum
    return (hasPathSum(root.left, targetSum - root.val) or
            hasPathSum(root.right, targetSum - root.val))</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Validate Binary Search Tree (LC 98)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Validate if tree is valid BST</p>
                            <div class="code">def isValidBST(root, min_val=float('-inf'), max_val=float('inf')):
    if not root:
        return True
    if root.val <= min_val or root.val >= max_val:
        return False
    return (isValidBST(root.left, min_val, root.val) and
            isValidBST(root.right, root.val, max_val))</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tree BFS -->
            <div class="pattern">
                <div class="pattern-header" onclick="toggle(this)">
                    <h2>Tree Breadth First Search (BFS)</h2>
                </div>
                <div class="pattern-content">
                    <div class="section description">
                        <h3>üìã Description</h3>
                        <p>Traverse trees level by level using queue. Process all nodes at current level before next.</p>
                    </div>
                    <div class="section recognition">
                        <h3>üîç Recognition</h3>
                        <ul>
                            <li>Level-order traversal</li>
                            <li>Finding minimum depth</li>
                            <li>Level-by-level processing</li>
                            <li>Nodes at specific levels</li>
                        </ul>
                    </div>
                    <div class="section approach">
                        <h3>üéØ Approach</h3>
                        <ul>
                            <li>Use queue for nodes to visit</li>
                            <li>Process current level</li>
                            <li>Add children to queue</li>
                            <li>Continue until empty</li>
                        </ul>
                    </div>
                    <div class="examples">
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Binary Tree Level Order Traversal (LC 102)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Return level order traversal</p>
                            <div class="code">from collections import deque
if not root:
    return []
queue = deque([root])
result = []
while queue:
    level_size = len(queue)
    level = []
    for _ in range(level_size):
        node = queue.popleft()
        level.append(node.val)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    result.append(level)</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Minimum Depth of Binary Tree (LC 111)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Find minimum depth</p>
                            <div class="code">from collections import deque
if not root:
    return 0
queue = deque([(root, 1)])
while queue:
    node, depth = queue.popleft()
    if not node.left and not node.right:
        return depth
    if node.left:
        queue.append((node.left, depth + 1))
    if node.right:
        queue.append((node.right, depth + 1))</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Binary Tree Right Side View (LC 199)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>View from right side</p>
                            <div class="code">from collections import deque
if not root:
    return []
queue = deque([root])
result = []
while queue:
    level_size = len(queue)
    for i in range(level_size):
        node = queue.popleft()
        if i == level_size - 1:  # rightmost node
            result.append(node.val)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Binary Tree Zigzag Level Order (LC 103)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Zigzag level order traversal</p>
                            <div class="code">from collections import deque
if not root:
    return []
queue = deque([root])
result = []
left_to_right = True
while queue:
    level_size = len(queue)
    level = deque()
    for _ in range(level_size):
        node = queue.popleft()
        if left_to_right:
            level.append(node.val)
        else:
            level.appendleft(node.val)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    result.append(list(level))
    left_to_right = not left_to_right</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Binary Search -->
            <div class="pattern">
                <div class="pattern-header" onclick="toggle(this)">
                    <h2>Binary Search</h2>
                </div>
                <div class="pattern-content">
                    <div class="section description">
                        <h3>üìã Description</h3>
                        <p>Search sorted arrays in O(log n) time by eliminating half of search space each iteration.</p>
                    </div>
                    <div class="section recognition">
                        <h3>üîç Recognition</h3>
                        <ul>
                            <li>Sorted array search</li>
                            <li>Finding target/position</li>
                            <li>First/last occurrence</li>
                            <li>Peak/minimum finding</li>
                        </ul>
                    </div>
                    <div class="section approach">
                        <h3>üéØ Approach</h3>
                        <ul>
                            <li>Set left and right bounds</li>
                            <li>Calculate middle point</li>
                            <li>Compare with target</li>
                            <li>Eliminate half of space</li>
                        </ul>
                    </div>
                    <div class="examples">
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Binary Search (LC 704)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Classic binary search</p>
                            <div class="code">left, right = 0, len(nums) - 1
while left <= right:
    mid = (left + right) // 2
    if nums[mid] == target:
        return mid
    elif nums[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
return -1</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>First Bad Version (LC 278)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Find first bad version</p>
                            <div class="code">left, right = 1, n
while left < right:
    mid = (left + right) // 2
    if isBadVersion(mid):
        right = mid
    else:
        left = mid + 1
return left</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Find Peak Element (LC 162)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Find any peak element</p>
                            <div class="code">left, right = 0, len(nums) - 1
while left < right:
    mid = (left + right) // 2
    if nums[mid] > nums[mid + 1]:
        right = mid
    else:
        left = mid + 1
return left</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Search in Rotated Sorted Array (LC 33)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Search in rotated array</p>
                            <div class="code">left, right = 0, len(nums) - 1
while left <= right:
    mid = (left + right) // 2
    if nums[mid] == target:
        return mid
    
    # Check which half is sorted
    if nums[left] <= nums[mid]:  # left half sorted
        if nums[left] <= target < nums[mid]:
            right = mid - 1
        else:
            left = mid + 1
    else:  # right half sorted
        if nums[mid] < target <= nums[right]:
            left = mid + 1
        else:
            right = mid - 1</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Dynamic Programming -->
            <div class="pattern">
                <div class="pattern-header" onclick="toggle(this)">
                    <h2>Dynamic Programming</h2>
                </div>
                <div class="pattern-content">
                    <div class="section description">
                        <h3>üìã Description</h3>
                        <p>Solve problems by breaking into subproblems and storing results to avoid recomputation.</p>
                    </div>
                    <div class="section recognition">
                        <h3>üîç Recognition</h3>
                        <ul>
                            <li>Optimization problems</li>
                            <li>Counting problems</li>
                            <li>Decision problems</li>
                            <li>Overlapping subproblems</li>
                        </ul>
                    </div>
                    <div class="section approach">
                        <h3>üéØ Approach</h3>
                        <ul>
                            <li>Identify recurrence relation</li>
                            <li>Define base cases</li>
                            <li>Build solution bottom-up</li>
                            <li>Optimize space if possible</li>
                        </ul>
                    </div>
                    <div class="examples">
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Climbing Stairs (LC 70)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Ways to climb n stairs</p>
                            <div class="code">if n <= 2:
    return n
dp = [0] * (n + 1)
dp[1] = 1
dp[2] = 2
for i in range(3, n + 1):
    dp[i] = dp[i-1] + dp[i-2]
return dp[n]

# Space optimized
a, b = 1, 2
for i in range(3, n + 1):
    a, b = b, a + b
return b</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>House Robber (LC 198)</strong></span>
                                <span class="badge easy">Easy</span>
                            </div>
                            <p>Maximum money without robbing adjacent</p>
                            <div class="code">if not nums:
    return 0
if len(nums) == 1:
    return nums[0]

dp = [0] * len(nums)
dp[0] = nums[0]
dp[1] = max(nums[0], nums[1])

for i in range(2, len(nums)):
    dp[i] = max(dp[i-1], dp[i-2] + nums[i])
return dp[-1]</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Coin Change (LC 322)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Minimum coins to make amount</p>
                            <div class="code">dp = [float('inf')] * (amount + 1)
dp[0] = 0

for i in range(1, amount + 1):
    for coin in coins:
        if i >= coin:
            dp[i] = min(dp[i], dp[i - coin] + 1)

return dp[amount] if dp[amount] != float('inf') else -1</div>
                        </div>
                        <div class="example">
                            <div class="example-header">
                                <span><strong>Longest Increasing Subsequence (LC 300)</strong></span>
                                <span class="badge medium">Medium</span>
                            </div>
                            <p>Length of longest increasing subsequence</p>
                            <div class="code">dp = [1] * len(nums)
for i in range(1, len(nums)):
    for j in range(i):
        if nums[i] > nums[j]:
            dp[i] = max(dp[i], dp[j] + 1)
return max(dp)

# Binary search approach O(n log n)
import bisect
tails = []
for num in nums:
    pos = bisect.bisect_left(tails, num)
    if pos == len(tails):
        tails.append(num)
    else:
        tails[pos] = num
return len(tails)</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function toggle(header) {
            const content = header.nextElementSibling;
            content.classList.toggle('active');
        }
        
        // Open first pattern by default
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelector('.pattern-content').classList.add('active');
        });
    </script>
</body>
</html>